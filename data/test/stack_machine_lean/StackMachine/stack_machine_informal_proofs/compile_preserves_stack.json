{
    "problem_name": "compile_preserves_stack",
    "informal_statement": "Running the compiled code of an expression e starting from an arbitrary stack s produces a stack whose top is ProgResult.ok (eval map e) and whose tail is the original s. Formally: run_program map s (compile e) = ProgResult.ok (eval map e) :: s.",
    "informal_proof": "Prove by structural induction on e, generalizing the initial stack s (i.e. `induction e generalizing s`).\n\n- Case num n: compile e = [Instr.push n]; evaluate `run_program` and `run_instr` to get ProgResult.ok n :: s. Use `simp`/`rw` with `compile` and `run_program` definitions.\n- Case var v: similar with Instr.load and map v.\n- Case add e1 e2: compile e = compile e1 ++ compile e2 ++ [Instr.add]. Use the previously proved run_program_append to reassociate runs:\n    first rewrite (compile e1 ++ compile e2 ++ [Instr.add]) as (compile e1 ++ compile e2) ++ [Instr.add],\n    then use run_program_append to get run_program map s ((compile e1 ++ compile e2) ++ [Instr.add]) = run_program map (run_program map s (compile e1 ++ compile e2)) [Instr.add],\n    and again use run_program_append to split compile e1 ++ compile e2.\n  Apply the inductive hypotheses:\n    IH on e1 with stack s gives run_program map s (compile e1) = ok (eval e1) :: s,\n    IH on e2 with stack ok (eval e1) :: s gives run_program map (ok (eval e1) :: s) (compile e2) = ok (eval e2) :: ok (eval e1) :: s.\n  Running [Instr.add] then yields ok (eval e2 + eval e1) :: s; finish by using Nat.add_comm to swap the summands and get ok (eval e1 + eval e2) :: s.\n\nHelper lemma used (spell-out):\n  theorem run_program_append (map : Var â†’ Nat) (s : List ProgResult) (p q : Program) :\n    run_program map s (p ++ q) = run_program map (run_program map s p) q\n\nOther useful fact: Nat.add_comm (a b : Nat) : a + b = b + a.\n\nTactics sketch: `induction e generalizing s; simp [compile, run_program, run_instr]; rw [run_program_append, run_program_append]; rw [IH_e1, IH_e2]; simp; rw [Nat.add_comm]`."
  }